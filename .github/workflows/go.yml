name: Build and Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  # Linux builds
  build-linux-amd64:
    name: Build Linux AMD64
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -ldflags '-extldflags "-static"' -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-linux-amd64
        path: gocl

  build-linux-arm64:
    name: Build Linux ARM64
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -a -ldflags '-extldflags "-static"' -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-linux-arm64
        path: gocl

  # Windows builds
  build-windows-amd64:
    name: Build Windows AMD64
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        go build -v -o gocl.exe
      env:
        GOOS: windows
        GOARCH: amd64

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-windows-amd64
        path: gocl.exe

  # macOS builds
  build-darwin-amd64:
    name: Build macOS AMD64
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        GOOS=darwin GOARCH=amd64 go build -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-darwin-amd64
        path: gocl

  build-darwin-arm64:
    name: Build macOS ARM64
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        GOOS=darwin GOARCH=arm64 go build -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-darwin-arm64
        path: gocl

  # Other Unix-like systems
  build-solaris-amd64:
    name: Build Solaris AMD64
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        GOOS=solaris GOARCH=amd64 go build -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-solaris-amd64
        path: gocl

  build-freebsd-amd64:
    name: Build FreeBSD AMD64
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        cache: true

    - name: Get dependencies
      run: |
        go mod download
        go mod tidy

    - name: Build
      run: |
        GOOS=freebsd GOARCH=amd64 go build -v -o gocl .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: gocl-freebsd-amd64
        path: gocl

  release:
    name: Create Release
    runs-on: ubuntu-latest
    # Запускаем при пуше в main или при создании тега
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if commit is draft (only for main branch)
        id: check_draft
        if: github.ref == 'refs/heads/main'
        run: |
          # Получаем заголовок коммита, который вызвал этот workflow
          COMMIT_MESSAGE=$(git log -1 --pretty=format:%s ${{ github.sha }})
          echo "Trigger commit message: $COMMIT_MESSAGE"
          
          # Проверяем, заканчивается ли заголовок на "-draft"
          if [[ "$COMMIT_MESSAGE" == *"-draft" ]]; then
            echo "Commit is marked as draft. Skipping release creation."
            echo "is_draft=true" >> $GITHUB_OUTPUT
          else
            echo "Commit is not draft. Proceeding with release creation."
            echo "is_draft=false" >> $GITHUB_OUTPUT
          fi


      - name: Skip release for draft commits (only for main branch)
        if: github.ref == 'refs/heads/main' && steps.check_draft.outputs.is_draft == 'true'
        run: |
          echo "Skipping release creation because the commit is marked as draft."
          exit 1

      - name: Wait for all build jobs to complete
        id: wait_builds
        run: |
          RUN_ID=${{ github.run_id }}
          REPO=${{ github.repository }}
          TIMEOUT=600 # 10 минут
          INTERVAL=15
          ELAPSED=0
          
          echo "Waiting for build jobs to complete in run $RUN_ID for repo $REPO"
          echo "This job will wait up to $TIMEOUT seconds."
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Получаем список всех джобов, исключая текущую
            JOBS_JSON=$(gh api "/repos/$REPO/actions/runs/$RUN_ID/jobs" \
              --jq ".jobs[] | select(.name != \"Create Release\") | {name: .name, status: .status, conclusion: .conclusion}")
            
            # Считаем общее количество джобов сборки (начинающихся с "Build")
            TOTAL_BUILD_JOBS=$(echo "$JOBS_JSON" | jq -r 'select(.name | startswith("Build")) | .name' | wc -l)
            
            # Считаем количество завершенных джобов сборки
            COMPLETED_BUILD_JOBS=$(echo "$JOBS_JSON" | jq -r 'select(.status == "completed") | select(.name | startswith("Build")) | .name' | wc -l)
            
            # Считаем количество успешно завершенных джобов сборки
            SUCCESSFUL_BUILD_JOBS=$(echo "$JOBS_JSON" | jq -r 'select(.status == "completed" and .conclusion == "success") | select(.name | startswith("Build")) | .name' | wc -l)
            
            echo "Build jobs: $COMPLETED_BUILD_JOBS completed out of $TOTAL_BUILD_JOBS total. Successful: $SUCCESSFUL_BUILD_JOBS"
            
            # Если все джобы сборки завершены
            if [ "$TOTAL_BUILD_JOBS" -gt 0 ] && [ "$COMPLETED_BUILD_JOBS" -eq "$TOTAL_BUILD_JOBS" ]; then
              echo "All $TOTAL_BUILD_JOBS build jobs have completed."
              if [ "$SUCCESSFUL_BUILD_JOBS" -gt 0 ]; then
                echo "At least $SUCCESSFUL_BUILD_JOBS build job(s) succeeded."
                echo "all_builds_completed=true" >> $GITHUB_OUTPUT
                echo "at_least_one_build_succeeded=true" >> $GITHUB_OUTPUT
              else
                echo "No build jobs succeeded."
                echo "all_builds_completed=true" >> $GITHUB_OUTPUT
                echo "at_least_one_build_succeeded=false" >> $GITHUB_OUTPUT
              fi
              exit 0
            else
              echo "Waiting for remaining $((TOTAL_BUILD_JOBS - COMPLETED_BUILD_JOBS)) build job(s) to complete..."
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "Timeout reached. Not all build jobs completed in time."
          echo "all_builds_completed=false" >> $GITHUB_OUTPUT
          echo "at_least_one_build_succeeded=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fail if no builds succeeded or timeout
        if: steps.wait_builds.outputs.all_builds_completed == 'true' && steps.wait_builds.outputs.at_least_one_build_succeeded == 'false'
        run: |
          echo "All build jobs completed, but none succeeded. Aborting release creation."
          exit 1
          
      - name: Fail on timeout
        if: steps.wait_builds.outputs.all_builds_completed == 'false'
        run: |
          echo "Timeout reached while waiting for build jobs to complete. Aborting release creation."
          exit 1

      - name: Download all artifacts
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true'
        uses: actions/download-artifact@v4

      - name: Create release artifacts
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true'
        run: |
          # Create release directory
          mkdir -p release
          
          # Определяем имя тега/релиза
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Для тегов используем имя тега
            RELEASE_VERSION=${{ github.ref_name }}
          else
            # Для main используем "latest"
            RELEASE_VERSION="latest"
          fi
          
          echo "Release version: $RELEASE_VERSION"
          
          # Process each artifact directory
          shopt -s nullglob # Handle case where no gocl-* dirs exist
          for dir in gocl-*/; do
            if [ -d "$dir" ]; then
              # Get platform info from directory name
              platform=$(echo "$dir" | sed 's/\/$//' | sed 's/gocl-//')
              
              # Create archive based on platform
              if [[ "$platform" == *"windows"* ]]; then
                # Windows - create ZIP
                (cd "$dir" && zip -r "../release/gocl-$RELEASE_VERSION-$platform.zip" .)
              else
                # Unix-like systems - create tar.gz
                (cd "$dir" && tar -czf "../release/gocl-$RELEASE_VERSION-$platform.tar.gz" .)
              fi
            fi
          done
          shopt -u nullglob

      - name: Setup Git for tag operations
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true'
        run: |
          # Настраиваем Git identity
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
        env:
          GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }}

      - name: Delete and Recreate 'latest' tag (only for main branch)
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true' && github.ref == 'refs/heads/main'
        run: |
          # Получаем SHA последнего коммита в main
          COMMIT_SHA=$(git rev-parse HEAD)
          TAG_NAME="latest"
          
          echo "Current commit SHA: $COMMIT_SHA"
          
          # Удаляем релиз, если он существует (игнорируем ошибки, если нет релиза)
          gh release delete "$TAG_NAME" --yes 2>/dev/null || echo "Release $TAG_NAME did not exist or could not be deleted."
          
          # Удаляем тег, если он существует на remote
          git push origin ":refs/tags/$TAG_NAME" 2>/dev/null || echo "Remote tag $TAG_NAME was not found to delete."
          
          # Удаляем локальный тег, если он существует
          git tag -d "$TAG_NAME" 2>/dev/null || echo "Local tag $TAG_NAME was not found to delete."
          
          # Создаем аннотированный тег на текущем коммите
          git tag -a "$TAG_NAME" "$COMMIT_SHA" -m "Latest build from main branch. Commit: $COMMIT_SHA"
          
          # Пушим новый тег
          git push origin "$TAG_NAME"
          
          echo "Tag '$TAG_NAME' has been recreated on commit $COMMIT_SHA"
        env:
          GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }}

      - name: Delete existing release assets
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true'
        uses: mknejp/delete-release-assets@v1
        with:
          token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          # Используем соответствующий тег
          tag: ${{ github.ref == 'refs/heads/main' && 'latest' || github.ref_name }}
          assets: '*'
          fail-if-no-release: false

      - name: Create or Update Release
        if: steps.wait_builds.outputs.at_least_one_build_succeeded == 'true'
        uses: softprops/action-gh-release@v1
        with:
          # Используем соответствующий тег
          tag_name: ${{ github.ref == 'refs/heads/main' && 'latest' || github.ref_name }}
          name: ${{ github.ref == 'refs/heads/main' && 'Latest Development Build' || format('Release {0}', github.ref_name) }}
          body: |
            ${{ github.ref == 'refs/heads/main' && 'Latest automated build from the main branch.' || format('Release version {0}', github.ref_name) }}
            Commit: ${{ github.sha }}
            Build time: $(date -u)
          files: |
            release/gocl-${{ github.ref == 'refs/heads/main' && 'latest' || github.ref_name }}-*.zip
            release/gocl-${{ github.ref == 'refs/heads/main' && 'latest' || github.ref_name }}-*.tar.gz
          draft: false
          prerelease: ${{ github.ref == 'refs/heads/main' }}
        env:
          GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }}